(this["webpackJsonplambda-react"]=this["webpackJsonplambda-react"]||[]).push([[0],[,,,,function(e,a,t){e.exports=t(15)},,,,,function(e,a,t){},function(e,a,t){},function(e,a,t){},function(e,a,t){},function(e,a,t){},function(e,a,t){},function(e,a,t){"use strict";t.r(a);var n=t(0),l=t.n(n),r=t(3),c=t.n(r),o=(t(9),t(10),function(e){var a=e.to,t=e.children,n=e.external,r=void 0===n||n,c={href:a,target:r?"_blank":"_self",rel:r?"noopener noreferrer":void 0};return l.a.createElement("a",Object.assign({className:"link"},c),t)}),m=t(1),u=l.a.createContext({showAll:!1,setShowAll:null}),s=function(e){var a=e.children,t=Object(n.useState)(!1),r=Object(m.a)(t,2),c=r[0],o=r[1];return l.a.createElement(u.Provider,{value:{showAll:c,setShowAll:o}},a)},i=(t(11),function(e){var a=e.heading,t=e.children;return l.a.createElement("section",null,l.a.createElement("h2",null,a),l.a.createElement(s,null,t))}),E=function(){return l.a.createElement(i,{heading:"Introduction"},l.a.createElement("p",null,"This project is an attempt to implement something ",l.a.createElement("b",null,"close")," to"," ",l.a.createElement(o,{to:"https://en.wikipedia.org/wiki/Lambda_calculus"},"lambda calculus")," ","in ",l.a.createElement(o,{to:"https://reactjs.org/"},"React"),". Why? Why not? Mostly for fun, but also to learn more about both. The idea for this was heavily inspired by Jim Weirich's amazing talk"," ",l.a.createElement(o,{to:"https://www.youtube.com/watch?v=FITJMJjASUs"},"Y Not - Adventures in Functional Programming"),"."),l.a.createElement("p",null,"To jump right into the code, follow these links to the various React components:"),l.a.createElement("ul",null,l.a.createElement("li",null,l.a.createElement(o,{to:"https://github.com/thoughtbyte/lambda-calculus-in-react/blob/master/src/components/%CE%B2Reduction/index.tsx"},"\u03b2Reduction")),l.a.createElement("li",null,l.a.createElement(o,{to:"https://github.com/thoughtbyte/lambda-calculus-in-react/blob/master/src/components/IDENTITY/index.tsx"},"IDENTITY")),l.a.createElement("li",null,l.a.createElement(o,{to:"https://github.com/thoughtbyte/lambda-calculus-in-react/tree/master/src/components/numbers"},"numbers")),l.a.createElement("li",null,l.a.createElement(o,{to:"https://github.com/thoughtbyte/lambda-calculus-in-react/tree/master/src/components/logic"},"logic")),l.a.createElement("li",null,"pairs: in progress"),l.a.createElement("li",null,"recursion: in progress")),l.a.createElement("p",null,"The code snippets in this tutorial omit some things like type checking for readability."),l.a.createElement("p",null,"Feedback? Email"," ",l.a.createElement(o,{to:"mailto:vgabruzzo@gmail.com",external:!1},"vgabruzzo@gmail.com")))},d=(t(12),function(e){var a=e.children;return l.a.createElement("span",{className:"codeBlock"},a)}),h=(t(13),{IDENTITY:"\u03bbx.x",ZERO:"\u03bbf.\u03bbx.x",ONE:"\u03bbf.\u03bbx.f x",TWO:"\u03bbf.\u03bbx.f (f x)",THREE:"\u03bbf.\u03bbx.f (f (f x))",SUCCESSOR:"\u03bbn.\u03bbf.\u03bbx.f (n f x)",TRUE:"\u03bbx.\u03bby.x",FALSE:"\u03bbx.\u03bby.y",AND:"\u03bbp.\u03bbq.p q p",OR:"\u03bbp.\u03bbq.p p q",IF_THEN_ELSE:"\u03bbp.\u03bba.\u03bbb.p a b",PAIR:"\u03bbx.\u03bby.\u03bbf.f x y",FIRST:"\u03bbp.p (\u03bbx.\u03bby.x x y)",SECOND:"\u03bbp.p (\u03bbx.\u03bby.y x y)"}),p=function(e){var a=e.name,t=Object(n.useState)(!1),r=Object(m.a)(t,2),c=r[0],o=r[1],s=Object(n.useContext)(u).showAll;return l.a.createElement("span",{className:"label",onClick:function(){return"ANONYMOUS"!==a&&!s&&o(!c)},onKeyPress:function(e){return"ANONYMOUS"!==a&&("Enter"===e.key||" "===e.key)&&!s&&o(!c)},tabIndex:0},c||s?h[a]:a)},f=function(e){var a=e.\u03bb,t=e.args.reduce((function(e,a){return e(a)}),a);return"function"===typeof t?l.a.createElement(p,{name:t.displayName||"ANONYMOUS"}):t},g=function(e){var a=e.args;return l.a.createElement(f,{"\u03bb":function(e){return e},args:a})};g.displayName="IDENTITY";var b=g,T=function(){return l.a.createElement(i,{heading:"Basics"},l.a.createElement("p",null,"Lambda calculus can simulate any"," ",l.a.createElement(o,{to:"https://en.wikipedia.org/wiki/Turing_machine"},"Turing machine"),". It does so with only three components:"),l.a.createElement("ul",null,l.a.createElement("li",null,"variables: ",l.a.createElement("code",null,"x")),l.a.createElement("li",null,"function abstraction: ",l.a.createElement("code",null,"\u03bbx.x")),l.a.createElement("li",null,"function application: ",l.a.createElement("code",null,"\u03bbx.x 1"))),l.a.createElement("p",null,"The lambda symbol above signifies that the variable ",l.a.createElement("code",null,"x")," is bound to the ",l.a.createElement("code",null,"x")," in the body of the function abstraction. This example is the identity function, it returns whatever argument is passed in. The function application evaluates to ",l.a.createElement("code",null,"1"),". This process of replacing variables with their arguments and evaluating the expression is called \u03b2-reduction."),l.a.createElement("p",null,"Implementing lambda calculus in React begins with building a \u03b2-reduction component. Here is the identity function being applied with the argument"," ",l.a.createElement("code",null,"1")," in React:",l.a.createElement(d,null,"<\u03b2Reduction \u03bb={x => x} args={[1]} />"),"And here is what this component looks like under the hood:",l.a.createElement(d,null,"const \u03b2Reduction: FC<\u03b2ReductionProps> = ({ \u03bb, args }) => {\n  const application = args.reduce(\n    (accumulator, current) => accumulator(current),\n    \u03bb\n  );\n\n  return application;\n};"),l.a.createElement("code",null,"\u03b2Reduction")," calls ",l.a.createElement("code",null,"reduce")," which in turn calls the lambda prop on the first argument passed in. For each subsequent argument, it calls the result of the previous iteration on that argument. Hence, the result of calling a lambda on an argument is another lambda function (except for possibly the last iteration, but only because this allows it to render strings and numbers for demo purposes)."),l.a.createElement("p",null,"On the left side of the \u2192 below is the lambda expression for the identity function with ",l.a.createElement("code",null,"1")," passed in as an argument. Lambda expressions are always anonymous but I've included labels for readability. Click on any label and you'll reveal the lambda expression. On the right side of the \u2192 is the ",l.a.createElement("code",null,"\u03b2Reduction")," component being rendered by React with ",l.a.createElement("code",null,"x => x")," passed as the ",l.a.createElement("code",null,"\u03bb")," prop and"," ",l.a.createElement("code",null,"[1]")," passed as the ",l.a.createElement("code",null,"args")," prop.",l.a.createElement(d,null,l.a.createElement(p,{name:"IDENTITY"})," 1 \u2192 ",l.a.createElement(b,{args:[1]}))),l.a.createElement("p",null,"There are React components for common lambda expressions. Here's the"," ",l.a.createElement("code",null,l.a.createElement(p,{name:"IDENTITY"}))," ","component:",l.a.createElement(d,null,"const IDENTITY: FC<LambdaExprProps> = ({ args }) => (\n  <\u03b2Reduction \u03bb={x => x} args={args} />\n);"),"And here is the"," ",l.a.createElement("code",null,l.a.createElement(p,{name:"IDENTITY"}))," ","component being rendered with itself as an argument. Unsurprisingly, it returns itself. Note: since"," ",l.a.createElement("code",null,l.a.createElement(p,{name:"IDENTITY"}))," ","is a function and we can't render functions, the ",l.a.createElement("code",null,"\u03b2Reduction")," ","component actually renders its ",l.a.createElement("code",null,"displayName")," property:",l.a.createElement(d,null,l.a.createElement(p,{name:"IDENTITY"})," ",l.a.createElement(p,{name:"IDENTITY"})," \u2192"," ",l.a.createElement(b,{args:[b]})),"The JSX React is rendering on the right side of the arrow:",l.a.createElement(d,null,"<IDENTITY args={[IDENTITY]} />")),l.a.createElement("p",null,"We can nest these lambdas as much as we'd like. For example:",l.a.createElement(d,null,l.a.createElement(p,{name:"IDENTITY"})," (",l.a.createElement(p,{name:"IDENTITY"})," ",l.a.createElement(p,{name:"IDENTITY"}),") \u2192 ",l.a.createElement(b,{args:[l.a.createElement(b,{args:[b]})]})),"And the JSX for this \u03b2-reduction:",l.a.createElement(d,null,"<IDENTITY args={[<IDENTITY args={[IDENTITY]} />]} />")),l.a.createElement("p",null,"That's it for the very basics of lambda calculus: variables, functions, and function application. There's not much to it. Nor is there much to implementing something like it with React components. We've already used something other than these three things though: numbers. We cheated. Next we'll learn how to represent numbers in lambda calculus."))},x=function(e){var a=e.args;return l.a.createElement(f,{"\u03bb":function(e){return function(e){return e}},args:a})};x.displayName="ZERO";var w=function(e){var a=e.args;return l.a.createElement(f,{"\u03bb":function(e){return function(a){if("function"===typeof e)return e(a)}},args:a})};w.displayName="ONE";var y=function(e){var a=e.args;return l.a.createElement(f,{"\u03bb":function(e){return function(a){if("function"===typeof e)return e(e(a))}},args:a})};y.displayName="TWO";var N=function(e){var a=e.args;return l.a.createElement(f,{"\u03bb":function(e){return function(a){if("function"===typeof e)return e(e(e(a)))}},args:a})};N.displayName="THREE";var R=function(e){var a=e.args;return l.a.createElement(f,{"\u03bb":function(e){return function(a){return function(t){if("function"===typeof a&&"function"===typeof e)return a(e({args:[a,t]}))}}},args:a})};R.displayName="SUCCESSOR";var v=R,I=function(){return l.a.createElement(i,{heading:"Numbers"},l.a.createElement("p",null,"One common approach to encoding numbers, and other data and operators, is"," ",l.a.createElement(o,{to:"https://en.wikipedia.org/wiki/Church_encoding"},"Church encoding"),". A Church encoding for a number is a function that takes two arguments,"," ",l.a.createElement("code",null,"f")," and ",l.a.createElement("code",null,"x"),", and applies ",l.a.createElement("code",null,"f")," to"," ",l.a.createElement("code",null,"x")," any number of times. To represent ",l.a.createElement("code",null,"1")," it applies once, ",l.a.createElement("code",null,"2")," twice, and so on. ",l.a.createElement("code",null,"0")," is represented by the lambda that doesn't apply ",l.a.createElement("code",null,"f")," to ",l.a.createElement("code",null,"x"),". Here are the lambda expressions:"),l.a.createElement("ul",null,l.a.createElement("li",null,l.a.createElement("code",null,"0"),": ",l.a.createElement("code",null,"\u03bbf.\u03bbx.x")),l.a.createElement("li",null,l.a.createElement("code",null,"1"),": ",l.a.createElement("code",null,"\u03bbf.\u03bbx.f x")),l.a.createElement("li",null,l.a.createElement("code",null,"2"),": ",l.a.createElement("code",null,"\u03bbf.\u03bbx.f (f x)")),l.a.createElement("li",null,l.a.createElement("code",null,"3"),": ",l.a.createElement("code",null,"\u03bbf.\u03bbx.f (f (f x))"))),l.a.createElement("p",null,"The"," ",l.a.createElement("code",null,l.a.createElement(p,{name:"IDENTITY"}))," ","lambda only takes in one argument. To represent numbers, we take in two. However, lambda expressions can only take in one argument. Lambdas that require two arguments are"," ",l.a.createElement(o,{to:"https://en.wikipedia.org/wiki/Currying"},"curried"),". That is, they take in one argument, then return a function that takes in the second argument, and so on. This is how we represent these lambdas in JavaScript:"),l.a.createElement("ul",null,l.a.createElement("li",null,l.a.createElement("code",null,"0"),": ",l.a.createElement("code",null,"f => x => x")),l.a.createElement("li",null,l.a.createElement("code",null,"1"),": ",l.a.createElement("code",null,"f => x => f(x)")),l.a.createElement("li",null,l.a.createElement("code",null,"2"),": ",l.a.createElement("code",null,"f => x => f(f(x))")),l.a.createElement("li",null,l.a.createElement("code",null,"3"),": ",l.a.createElement("code",null,"f => x => f(f(f(x)))"))),l.a.createElement("p",null,"To represent these numbers as React components, we pass the JavaScript representations of the lambdas to the ",l.a.createElement("code",null,"\u03bb")," prop of the"," ",l.a.createElement("code",null,"\u03b2Reduction")," component:",l.a.createElement(d,null,"const ZERO: FC<LambdaExprProps> = ({ args }) => (\n  <\u03b2Reduction \u03bb={f => x => x} args={args} />\n);\n\nconst ONE: FC<LambdaExprProps> = ({ args }) => (\n  <\u03b2Reduction \u03bb={f => x => f(x)} args={args} />\n);\n\nconst TWO: FC<LambdaExprProps> = ({ args }) => (\n  <\u03b2Reduction \u03bb={f => x => f(f(x))} args={args} />\n);")),l.a.createElement("p",null,"We can now avoid cheating and pass the"," ",l.a.createElement("code",null,l.a.createElement(p,{name:"ONE"}))," ","lambda to"," ",l.a.createElement("code",null,l.a.createElement(p,{name:"IDENTITY"})),":",l.a.createElement(d,null,l.a.createElement(p,{name:"IDENTITY"})," ",l.a.createElement(p,{name:"ONE"})," \u2192"," ",l.a.createElement(b,{args:[w]}))),l.a.createElement("p",null,"And the JSX being rendered on the right side:",l.a.createElement(d,null,"<IDENTITY args={[ONE]} />")),l.a.createElement("p",null,"So we have numbers, or at least a few of them, and we have an"," ",l.a.createElement("code",null,l.a.createElement(p,{name:"IDENTITY"}))," ","function. Let's do something more interesting. Let's make a function that will give us the successor to any number we pass into it. The lambda expression for this: ",l.a.createElement(d,null,"\u03bbn.\u03bbf.\u03bbx.f (n f x)")," This lambda takes three arguments: a number, a function, and something to apply the function to. Suppose you pass in"," ",l.a.createElement("code",null,l.a.createElement(p,{name:"TWO"}))," ","as the first argument. That would reduce to:"," ",l.a.createElement(d,null,"\u03bbf.\u03bbx.f (TWO f x)")," Then, for whatever"," ",l.a.createElement("code",null,"f")," and ",l.a.createElement("code",null,"x")," we pass in, we apply ",l.a.createElement("code",null,"f")," to whatever"," ",l.a.createElement("code",null,l.a.createElement(p,{name:"TWO"}))," ","returns when we pass ",l.a.createElement("code",null,"f")," and ",l.a.createElement("code",null,"x")," to it."," ",l.a.createElement("code",null,l.a.createElement(p,{name:"TWO"}))," ","returns the application of ",l.a.createElement("code",null,"f")," to ",l.a.createElement("code",null,"x")," twice. So... we apply ",l.a.createElement("code",null,"f")," to the application of ",l.a.createElement("code",null,"f")," to"," ",l.a.createElement("code",null,"x")," twice. That is, the successor lambda when given the argument"," ",l.a.createElement("code",null,l.a.createElement(p,{name:"TWO"}))," ","returns a function that takes an ",l.a.createElement("code",null,"f")," and an ",l.a.createElement("code",null,"x")," and returns three applications of ",l.a.createElement("code",null,"f")," to ",l.a.createElement("code",null,"x"),". That is, it returns the Church encoding for ",l.a.createElement("code",null,"3"),"."),l.a.createElement("p",null,"As a React component:",l.a.createElement(d,null,"const SUCCESSOR: FC<LambdaExprProps> = ({ args }) => (\n  <\u03b2Reduction\n    \u03bb={n => f => x => f({ args: [n({ args: [f, x] })] })}}\n    args={args}\n  />\n);"),"One important thing to note here is that we can't just pass arguments directly to our functions in many cases, since ",l.a.createElement("code",null,"\u03b2Reduction")," ","expects an ",l.a.createElement("code",null,"args")," prop that it reduces over. Further, our functions are curried, so passing multiple arguments normally wouldn't work. Rendering our component:",l.a.createElement(d,null,l.a.createElement(p,{name:"SUCCESSOR"})," ",l.a.createElement(p,{name:"TWO"})," \u2192"," ",l.a.createElement(v,{args:[y]})),"Even though we have a"," ",l.a.createElement("code",null,l.a.createElement(p,{name:"THREE"}))," ","component, lambda expressions and our components may return new anonymous functions, so we can't display the name here. However, if we"," ",l.a.createElement("code",null,".toString()")," the actual function being returned, we get:",l.a.createElement(d,null,"f => x => f({ args: [n({ args: [f, x] })] })")," ","Since we know that ",l.a.createElement("code",null,"n")," refers to"," ",l.a.createElement("code",null,l.a.createElement(p,{name:"TWO"}))," ","we know that the anonymous function here is equivalent to"," ",l.a.createElement("code",null,l.a.createElement(p,{name:"THREE"})),"."),l.a.createElement("p",null,"Addition, subtraction, and multiplication components will be added here in the future."))},S=function(e){var a=e.args;return l.a.createElement(f,{"\u03bb":function(e){return function(a){return e}},args:a})};S.displayName="TRUE";var A=S,O=function(e){var a=e.args;return l.a.createElement(f,{"\u03bb":function(e){return function(e){return e}},args:a})};O.displayName="FALSE";var k=O,F=function(e){var a=e.args;return l.a.createElement(f,{"\u03bb":function(e){return function(a){if("function"===typeof e)return e({args:[a,e]})}},args:a})};F.displayName="AND";var L=F,D=function(e){var a=e.args;return l.a.createElement(f,{"\u03bb":function(e){return function(a){if("function"===typeof e)return e({args:[e,a]})}},args:a})};D.displayName="OR";var C=D,U=function(e){var a=e.args;return l.a.createElement(f,{"\u03bb":function(e){return function(a){return function(t){if("function"===typeof e)return e({args:[a,t]})}}},args:a})};U.displayName="IF_THEN_ELSE";var Y=U,W=function(){return l.a.createElement(i,{heading:"Logic"},l.a.createElement("p",null,"The Church encodings for true and false are:"),l.a.createElement("ul",null,l.a.createElement("li",null,"true: ",l.a.createElement("code",null,"\u03bbx.\u03bby.x")),l.a.createElement("li",null,"false: ",l.a.createElement("code",null,"\u03bbx.\u03bby.y"))),l.a.createElement("p",null,"Both of these take in two arguments (remember, they're curried). True returns the first, false returns the second. As React components:",l.a.createElement(d,null,"const TRUE: FC<LambdaExprProps> = ({ args }) => (\n  <\u03b2Reduction \u03bb={x => y => x} args={args} />\n);\n\nconst FALSE: FC<LambdaExprProps> = ({ args }) => (\n  <\u03b2Reduction \u03bb={x => y => y} args={args} />\n);"),"And here they are in action. Again, the right side of the arrow is the output of the JSX being rendered:",l.a.createElement(d,null,l.a.createElement(p,{name:"TRUE"})," ",l.a.createElement(p,{name:"ZERO"})," ",l.a.createElement(p,{name:"ONE"})," \u2192"," ",l.a.createElement(A,{args:[x,w]})),l.a.createElement(d,null,l.a.createElement(p,{name:"FALSE"})," ",l.a.createElement(p,{name:"ONE"})," ",l.a.createElement(p,{name:"TWO"})," \u2192"," ",l.a.createElement(k,{args:[w,y]}))),l.a.createElement("p",null,"Here's a more complex example composing everything we have so far:",l.a.createElement(d,null,l.a.createElement(p,{name:"IDENTITY"})," (",l.a.createElement(p,{name:"TRUE"})," (",l.a.createElement(p,{name:"FALSE"})," ",l.a.createElement(p,{name:"ONE"})," ",l.a.createElement(p,{name:"TWO"}),") ",l.a.createElement(p,{name:"THREE"}),") \u2192"," ",l.a.createElement(b,{args:[l.a.createElement(A,{args:[l.a.createElement(k,{args:[w,y]}),N]})]})),"Click on all the labels for that one to see how it looks as lambda expressions. The labels reuse variables, so it is a bit confusing. This doesn't cause an issue for us since all of our variables are bound. The JSX for this example:",l.a.createElement(d,null,"<IDENTITY\n  args={[<TRUE args={[<FALSE args={[ONE, TWO]} />, THREE]} />]}\n/>")),l.a.createElement("p",null,"Given the preceding Church encodings for true and false, here are the lambda expressions for and and or:"),l.a.createElement("ul",null,l.a.createElement("li",null,"and: ",l.a.createElement("code",null,"\u03bbp.\u03bbq.p q p")),l.a.createElement("li",null,"or: ",l.a.createElement("code",null,"\u03bbp.\u03bbq.p p q"))),l.a.createElement("p",null,"Both of these take two arguments and these arguments should be"," ",l.a.createElement("code",null,l.a.createElement(p,{name:"TRUE"}))," ","or"," ",l.a.createElement("code",null,l.a.createElement(p,{name:"FALSE"})),". These were a little tricky the first time I encountered them. Here are the four possibilities of what happens with"," ",l.a.createElement("code",null,l.a.createElement(p,{name:"AND"})),":"),l.a.createElement("ul",null,l.a.createElement("li",null,"If"," ",l.a.createElement("code",null,l.a.createElement(p,{name:"TRUE"}))," ","is passed in as both ",l.a.createElement("code",null,"p")," and ",l.a.createElement("code",null,"q")," then it, as"," ",l.a.createElement("code",null,"p"),", is called on both arguments and it returns the first, which is"," ",l.a.createElement("code",null,l.a.createElement(p,{name:"TRUE"})),"."),l.a.createElement("li",null,"If"," ",l.a.createElement("code",null,l.a.createElement(p,{name:"TRUE"}))," ","is passed in as ",l.a.createElement("code",null,"p")," and"," ",l.a.createElement("code",null,l.a.createElement(p,{name:"FALSE"}))," ","is passed in as ",l.a.createElement("code",null,"q")," then"," ",l.a.createElement("code",null,l.a.createElement(p,{name:"TRUE"})),", as ",l.a.createElement("code",null,"p"),", is called on both arguments and it returns the first, which is ",l.a.createElement("code",null,"q"),", or"," ",l.a.createElement("code",null,l.a.createElement(p,{name:"FALSE"})),"."),l.a.createElement("li",null,"If"," ",l.a.createElement("code",null,l.a.createElement(p,{name:"FALSE"}))," ","is passed in as both ",l.a.createElement("code",null,"p")," and ",l.a.createElement("code",null,"q")," then it, as"," ",l.a.createElement("code",null,"p"),", is called on both arguments and it returns the second, which is"," ",l.a.createElement("code",null,l.a.createElement(p,{name:"FALSE"})),"."),l.a.createElement("li",null,"If"," ",l.a.createElement("code",null,l.a.createElement(p,{name:"FALSE"}))," ","is passed in as ",l.a.createElement("code",null,"p")," and"," ",l.a.createElement("code",null,l.a.createElement(p,{name:"TRUE"}))," ","is passed in as ",l.a.createElement("code",null,"q")," then"," ",l.a.createElement("code",null,l.a.createElement(p,{name:"FALSE"})),", as ",l.a.createElement("code",null,"p"),", is called on both arguments and it returns the second, which is ",l.a.createElement("code",null,"p"),", or"," ",l.a.createElement("code",null,l.a.createElement(p,{name:"FALSE"})),".")),l.a.createElement("p",null,"Here's our little lambda truth table for"," ",l.a.createElement("code",null,l.a.createElement(p,{name:"AND"})),l.a.createElement(d,null,l.a.createElement(p,{name:"AND"})," (",l.a.createElement(p,{name:"TRUE"})," ",l.a.createElement(p,{name:"TRUE"}),") \u2192 ",l.a.createElement(L,{args:[A,A]})),l.a.createElement(d,null,l.a.createElement(p,{name:"AND"})," (",l.a.createElement(p,{name:"TRUE"})," ",l.a.createElement(p,{name:"FALSE"}),") \u2192 ",l.a.createElement(L,{args:[A,k]})),l.a.createElement(d,null,l.a.createElement(p,{name:"AND"})," (",l.a.createElement(p,{name:"FALSE"})," ",l.a.createElement(p,{name:"FALSE"}),") \u2192 ",l.a.createElement(L,{args:[k,k]})),l.a.createElement(d,null,l.a.createElement(p,{name:"AND"})," (",l.a.createElement(p,{name:"FALSE"})," ",l.a.createElement(p,{name:"TRUE"}),") \u2192 ",l.a.createElement(L,{args:[k,A]})),"And the React component:",l.a.createElement(d,null,"const AND: FC<LambdaExprProps> = ({ args }) => (\n  <\u03b2Reduction\n    \u03bb={p => q => p({ args: [q, p] })}\n    args={args}\n  />\n);")),l.a.createElement("p",null,l.a.createElement("code",null,l.a.createElement(p,{name:"OR"}))," ","functions similarly. I leave it to the reader to work through it how we did for"," ",l.a.createElement("code",null,l.a.createElement(p,{name:"AND"})),". But, here's our little lambda truth table:",l.a.createElement(d,null,l.a.createElement(p,{name:"OR"})," (",l.a.createElement(p,{name:"TRUE"})," ",l.a.createElement(p,{name:"TRUE"}),") \u2192 ",l.a.createElement(C,{args:[A,A]})),l.a.createElement(d,null,l.a.createElement(p,{name:"OR"})," (",l.a.createElement(p,{name:"TRUE"})," ",l.a.createElement(p,{name:"FALSE"}),") \u2192 ",l.a.createElement(C,{args:[A,k]})),l.a.createElement(d,null,l.a.createElement(p,{name:"OR"})," (",l.a.createElement(p,{name:"FALSE"})," ",l.a.createElement(p,{name:"FALSE"}),") \u2192 ",l.a.createElement(C,{args:[k,k]})),l.a.createElement(d,null,l.a.createElement(p,{name:"OR"})," (",l.a.createElement(p,{name:"FALSE"})," ",l.a.createElement(p,{name:"TRUE"}),") \u2192 ",l.a.createElement(C,{args:[k,A]})),"And again, the React component:",l.a.createElement(d,null,"const OR: FC<LambdaExprProps> = ({ args }) => (\n  <\u03b2Reduction\n    \u03bb={p => q => p({ args: [p, q] })}\n    args={args}\n  />\n);"),"Notice all we did was switch the order of the arguments."),l.a.createElement("p",null,"Here is the lambda expression to represent branching logic:"),l.a.createElement("ul",null,l.a.createElement("li",null,"if...then...else: ",l.a.createElement("code",null,"\u03bbp.\u03bba.\u03bbb.p a b"))),l.a.createElement("p",null,"Given an argument ",l.a.createElement("code",null,"p")," which is either"," ",l.a.createElement("code",null,l.a.createElement(p,{name:"TRUE"}))," ","or"," ",l.a.createElement("code",null,l.a.createElement(p,{name:"FALSE"})),", this lambda will apply it to ",l.a.createElement("code",null,"a")," and ",l.a.createElement("code",null,"b"),". Well, we know how the boolean lambdas work. If ",l.a.createElement("code",null,"p")," is"," ",l.a.createElement("code",null,l.a.createElement(p,{name:"TRUE"}))," ","it will return the first argument, ",l.a.createElement("code",null,"a"),". And vice versa if"," ",l.a.createElement("code",null,"p")," is"," ",l.a.createElement("code",null,l.a.createElement(p,{name:"FALSE"})),".",l.a.createElement(d,null,l.a.createElement(p,{name:"IF_THEN_ELSE"})," (",l.a.createElement(p,{name:"TRUE"})," (",l.a.createElement(p,{name:"ONE"})," ",l.a.createElement(p,{name:"TWO"}),")) \u2192 ",l.a.createElement(Y,{args:[A,w,y]})),l.a.createElement(d,null,l.a.createElement(p,{name:"IF_THEN_ELSE"})," (",l.a.createElement(p,{name:"FALSE"})," (",l.a.createElement(p,{name:"ONE"})," ",l.a.createElement(p,{name:"TWO"}),")) \u2192 ",l.a.createElement(Y,{args:[k,w,y]})),"And finally, the React component implementation of branching logic in lambda calculus:",l.a.createElement(d,null,"const IF_THEN_ELSE: FC<LambdaExprProps> = ({ args }) => (\n  <\u03b2Reduction\n    \u03bb={p => a => b => p({ args: [a, b] })}\n    args={args}\n  />\n);\n")))},H=function(){return l.a.createElement(i,{heading:"Pairs"},l.a.createElement("p",null,"In progress..."))},q=function(){return l.a.createElement(i,{heading:"Recursion"},l.a.createElement("p",null,"In progress... One day, maybe."),l.a.createElement("p",null),l.a.createElement("p",null),l.a.createElement("p",null,"Feedback? Email"," ",l.a.createElement(o,{to:"mailto:vgabruzzo@gmail.com",external:!1},"vgabruzzo@gmail.com")))},P=(t(14),function(){return l.a.createElement("div",{className:"App"},l.a.createElement("header",{className:"App-header"},l.a.createElement("h1",{className:"h1"},"Lambda Calculus in React"),l.a.createElement("p",{className:"githubLink"},l.a.createElement(o,{to:"https://github.com/thoughtbyte/lambda-calculus-in-react"},"repo"))),l.a.createElement("main",null,l.a.createElement(E,null),l.a.createElement(T,null),l.a.createElement(I,null),l.a.createElement(W,null),l.a.createElement(H,null),l.a.createElement(q,null)))});Boolean("localhost"===window.location.hostname||"[::1]"===window.location.hostname||window.location.hostname.match(/^127(?:\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/));c.a.render(l.a.createElement(P,null),document.getElementById("root")),"serviceWorker"in navigator&&navigator.serviceWorker.ready.then((function(e){e.unregister()}))}],[[4,1,2]]]);
//# sourceMappingURL=main.c45c4821.chunk.js.map